####################
扩展docutils
####################
:category: Computer
:tags: Python
:date: 2008-01-25 08:17



.. contents:: 目录
    :backlinks: top

打算让自己的网志（也就是本网站啦）实现源代码自动语法高亮的功能，考虑了下感觉还是用 `SyntaxHighlighter <http://code.google.com/p/syntaxhighlighter/>`_ 的好：因为它是用JavaScript写的，这样可以把代码颜色的渲染工作转嫁到浏览器端^_^

目标
------

SyntaxHighlighter通过名为code的pre标签识别需要高亮显示的代码，并根据pre标签的class属性取得代码的语言。比如要是想高亮显示一段c代码的话就需要传给SyntaxHighlighter下面这样的内容:

.. code-block :: html

 <pre name="code" class="c">
    #include <stdio.h>
 
    int main()
    {
        printf ( "Hello world\
 " );
    }
 </pre>

我现在借助docutils格式化文本，而docutils的用来生成html的writer是没有这样的输出的，所以就得自己扩展了。

docutils的机制简述
------------------------

`docutils <http://docutils.sourceforge.net/>`_ 因为要支持多种输出格式，所以它内部采用了一种中间格式机制，格式文本的各种标记会被识别为各种element，标记之后的相关文本则成为该 element的属性。docutils一边解析格式文本，一边生成element，并在内部以tree的方式组织起来。在输出的时候，按照输出格式调用相应的writer，把这种中间格式转换为最终格式。所以不仅需要扩展格式文本解析处理，还要扩展html的生成处理。

docutils提供的格式控制中有一类叫directive的东西。其格式如下::

  +-------+-------------------------------+
  | ".. " | directive type "::" directive |
  +-------+ block                         |
          |                               |
          +-------------------------------+

directive type是用来识别directive的名字; :: 后是arguments，如果有option的话从下一行开始，格式为「name : value」; 最后还可以有contents，一般就是大段的文本了（对应我的需求就是需要高亮的代码），和option要空一行，可以多行，最后以一空行结束。

directive是可以被扩展的，只要定义并主持了自己的directive处理函数，docutils在碰到自定义directive type时，就会调用对应的directive处理函数，传入arguments、options和content还有其他一大堆相关参数。

扩展directive
----------------

docutils默认提供一个叫literal block的directive，其对contents部分的处理只是对特殊字符做了escape化，大致符合我不作处理的要求；而且输出为html时也是用的<pre> 标签，只是没有我要的name和class等属性而已（顺便说明：docutils有一个叫class的pending directive。之所以叫pending是因为其设定的内容不马上而是和下一个element一起被输出。通过连用class和literal block可以实现输出的<pre>标签中带class）。下面是追加定义的directive，叫sh，取的 SyntaxHighlighting之意：

.. code-block :: py

 from docutils import nodes
 from docutils.parsers.rst import directives
 
 def syntax_highlighting(name, arguments, options, content, lineno,
                         content_offset, block_text, state, state_machine):
     if not content:
         warning = state_machine.reporter.warning(
             'Content expected for the "%s" directive; none found.'
             % name, nodes.literal_block(block_text, block_text), line=lineno)
         return [warning]
     text = ''.join(content)
     node = nodes.literal_block(text, text)
 
     node.option = {"syntax":arguments[0]}
 
     node.line = content_offset + 1
     return [node]
 
 syntax_highlighting.content = True
 syntax_highlighting.arguments = (1, 0, 1)
 
 directives.register_directive("sh",syntax_highlighting)

上面的syntax_highlighting()函数就是我的directive的处理器了，基本盗版自docutils.parsers.rst.directives.body.block()，去除了不需要的对contents部分进行espace parse的部分。

如前所述，我的directive准备借用预定义的literal block的名义把自己添加到docutils内部的element tree中去。在上面的代码的第1行中被导入的nodes就是element tree对象；第12行用到的它的literal_block()方法就是创建一个literal block的element。为了能够和标准的literal block区别开来，第14行给新创建的这个literal block对象添加(这是动态语言专享特性)了一个叫option的dict，dict里用syntax为key存放了通过directive的argument接收到的语言类型。

接下来的第19、20行分别设定了directive是否接受content和argument的情况(代码中的1,0,1分别设置了required_arguments,optional_arguments,final_argument_whitespace的值)。

最后第22行注册本directive为sh。

扩展writer
-------------

接下来就该定制能够识别我们的特殊literal block的输出用的writer了。很自然地选取现存的html4css1为基础。

html4css1创建了一个HTMLTranslator对象去在解析element tree。在解析过程中，每遇到一个element就会去调用HTMLTranslator的visit_elementName()方法。  *elementName* 是具体的elment对象的名字，对于我的情况也就是literal_block了。下面是代码:

.. code-block:: py

 from docutils.writers.html4css1 import Writer,HTMLTranslator
 from docutils import writers
 
 class MyHtmlWriter(Writer):
     def __init__(self):
         writers.Writer.__init__(self)
         self.translator_class = MyHTMLTranslator
 
 class MyHTMLTranslator(HTMLTranslator):
     def visit_literal_block(self, node):
         if hasattr(node,'option') and node.option.has_key('syntax'):
             self.body.append(self.starttag(node, 'pre', NAME='code',CLASS=node.option['syntax']))
         else:
             HTMLTranslator.visit_literal_block(self,node)
 
 import docutils.writers
 
 original_get_writer_class = docutils.writers.get_writer_class
 
 def patched_get_writer_class(writer_name):
     if writer_name == "myhtml":
         return MyHtmlWriter
     else:
         return original_get_writer_class(writer_name)
 
 docutils.writers.get_writer_class = patched_get_writer_class


因为我只需要在碰到特殊element时把本来输出的<pre>修改一下，而content部分和结束标签都不需要动，所以上面的代码中，只重载了输出开始标签的方法visit_literal_block()。代码的第11行确认了是扩展的directive，然后调用starttag()去生成一个<pre>标签。注意大写的有名参数（NAME和CODE），starttag()会自动抓这些参数，以参数名为属性名；以参数值为属性值输出到<pre>标签中。

接下来要让docutils能够用新的writer。遗憾地是docutils似乎没有提供类似注册directive这样的注册机制。不过再次感谢动态语言的动态特性，从第18行开始可以看到我们是如何patch按名称取得writer对象的函数的^_^

然后在模板里设定好SyntaxHighlighter，就可以看到如本帖所示的代码自动高亮的效果了:-) 

注意在设置SyntaxHighlighter时务必把:

.. code-block:: js

 window.onload = function () {
    dp.SyntaxHighlighter.ClipboardSwf = '/flash/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code');
 }

放在html的<body>的最后，否则其后出现的代码都不会被渲染。




