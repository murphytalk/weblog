##############################################
regex历险之greedy matching
##############################################
:category: Computer
:tags: Linux
:date: 2005-03-05 17:00



sed居然不支持non-greedy matching

**缘起**

VeryCD虽然提供了一个很不错的介绍ED2kLink的汇总和介绍网站，但是它在所有从别处搜集来的文件上都要撒泡尿加上自己的VeryCD标记，实在让人讨厌。被它篡改过的文件名一般是这样的::

 [中文名称].The Original Name.[VeryCD].avi

有碍观瞻不说，如果是cue/bin的光盘镜像文件，因为cue里写的是原先的bin文件名，所以还得手工去改一下bin文件的文件名或者cue的内容，巨不方便，那个标记不去掉不足以平民愤！这就是我写"这个脚本":/Members/murphytalk/national.htm的动机了。

**改进**

但是这段脚本的不足之处很明显：只能匹配开头的[]内有六个西文字符或者三个中文字的情况（因为刚开始我是用这个脚本整理“老友记”的,就是三个中文字）。经由VeryCD下来的东西越来越多，开头[]里的东西千变万化，所以必须得改进。不就是要匹配方括弧里的东西吗，好办，我开始是这么写regex的::

 \\[.*\\]\\.\\(.*\\)\\[VeryCD.*\\]\\.\\(.*\\)

**挫折**

但结果非我所愿：什么也匹配不上。原因在于 .* 这样的repeater默认是贪婪的(greedy)，对于::

 [.*]

它会从第一个[开始一直匹配到最后一个]。我的情况就是给一直匹配到VeryCD后面的那个方括弧了。

为了从[开始匹配到遇到的第一个]，得告诉regex不准贪婪。标准的regex可以指定non-greedy模式，这样写::

 \\[.*?\\]\\.\\(.*\\)\\[VeryCD.*\\]\\.\\(.*\\)

应该可以了吧？No!只好求助万能的古狗，才发现人们在谈论 that's the reason why cannot use sed to parse HTML tags: 原来sed不支持non-greedy matching！

**一计不成，又生一计**

条条大道通罗马，既然sed没有non-greedy模式那我就不给你机会贪婪：我从[开始一直匹配其后所有的非]好了。考虑到]在regex里是个特殊字符，所以觉得还是Escape转义一下比较稳妥::

 \\[[^\\]]*\\]\\.\\(.*\\)\\[VeryCD.*\\]\\.\\(.*\\)

结果居然是不行。郁闷了一小下，才意识到在^符号后再用Escape转义是在添乱。。。最后的成品如下::

 \\[[^]]*\\]\\.\\(.*\\)\\[VeryCD.*\\]\\.\\(.*\\)

大功告成！现在我举手间就可以还一个目录下所有被verycd玷污过的文件（包括各子目录下，递归的）本来面目了;)
