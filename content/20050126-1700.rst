############################
Python的正则表达式支持
############################
:category: Computer
:tags: Python
:date: 2005-01-26 17:00



Python的正则表达式支持由re模块提供。首先用 ``re.compile(*pattern*[, flags])`` 得到一个compiled regular expression object。然后可以对这个object调用match和search方法进行匹配，成功地话返回一个Match Object，否则返回None。

match和search的区别在于前者要求在供搜索的字符串内全文范围内匹配，而search在供搜索的字符串内每遇到一次换行符就认为^匹配一次。具体如下例:

.. code-block:: python
   
  re.compile("a").match("ba", 1)           # succeeds
  re.compile("^a").search("ba", 1)         # fails; 'a' not at start
  re.compile("^a").search("a", 1)        # fails; 'a' not at start
  re.compile("^a", re.M).search("a", 1)  # succeeds
  re.compile("^a", re.M).search("ba", 1)   # fails; no preceding \


compiled regular expression object还有一个有用的方法split，可以用正则匹配试作分割符把一个字串分割到一个list中。比如有一个如下典型的csv格式文本:

.. code-block:: python
   
  "DATA ROW1 COLOUMN1","DATA ROW1 COLUMN2","DATA ROW1 COLUMN3"
  "DATA ROW2 COLOUMN1","DATA ROW2 COLUMN2","DATA ROW2 COLUMN3"

如果想得到各列的字串可以这么做:

.. code-block:: python
   
  #record中存放从csv中读入的某一行的字串
  regex=re.compile(r'","|^"|"')
  fields=regex.split(record)
  #list中第一个单元是空字串:^前的“字符串”
  fields.remove('')
  #list中最后一个单元也可能是空字串:后的“字符串”
  if fields[len(fields)-1]=="":
     fields.pop()

这样最后fields就是一个包含各列字串的list了。

注意调用compile方法时放在正则匹配式前的r表示后面字串中的\\不是字符串中的作为转义符的\\，这样可以避免如下情况：因为正则匹配式中\\也是转义符，如果再加上python字符串的\\作为转义符的含义，那么在正则匹配式中匹配\\写得成成**\\\\\\\\**了。

